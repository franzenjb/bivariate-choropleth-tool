<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Enhanced Bivariate Choropleth with ArcGIS Integration</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/topojson@3"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif; 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
        }
        
        .header {
            background: linear-gradient(135deg, #B71C1C, #8B0000);
            color: white;
            padding: 20px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        
        .container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .main-grid {
            display: grid;
            grid-template-columns: 300px 1fr 320px;
            gap: 20px;
            margin-top: 20px;
            height: calc(100vh - 150px);
        }
        
        .sidebar {
            background: white;
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
            overflow-y: auto;
        }
        
        .left-sidebar {
            /* Core functionality sidebar */
        }
        
        .right-sidebar {
            /* Demos and examples sidebar */
        }
        
        .map-container {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
            display: flex;
            flex-direction: column;
            position: relative;
        }
        
        #map {
            flex: 1;
            border-radius: 8px;
            overflow: hidden;
            min-height: 500px;
        }
        
        .workflow-section {
            margin-bottom: 30px;
            padding: 20px;
            border: 2px solid #e0e0e0;
            border-radius: 12px;
            background: #fafafa;
        }
        
        .workflow-section.primary {
            border-color: #B71C1C;
            background: linear-gradient(135deg, #fff5f5 0%, #ffebee 100%);
        }
        
        .workflow-section h2 {
            color: #B71C1C;
            margin-bottom: 15px;
            font-size: 18px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .workflow-section h3 {
            color: #666;
            margin-bottom: 10px;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .step-number {
            background: #B71C1C;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
        }
        
        .demo-section {
            margin-bottom: 25px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #2196F3;
        }
        
        .demo-section h3 {
            color: #2196F3;
            margin-bottom: 15px;
            font-size: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        input[type="file"], input[type="text"], input[type="url"], select, textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            transition: border 0.3s;
            margin-top: 8px;
        }
        
        input:focus, select:focus, textarea:focus {
            border-color: #B71C1C;
            outline: none;
            box-shadow: 0 0 0 3px rgba(183, 28, 28, 0.1);
        }
        
        .btn {
            background: #B71C1C;
            color: white;
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            display: inline-block;
            margin: 5px;
            text-align: center;
            width: 100%;
        }
        
        .btn:hover {
            background: #8B0000;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(183, 28, 28, 0.3);
        }
        
        .btn-primary {
            background: #B71C1C;
            font-size: 16px;
            padding: 15px 20px;
        }
        
        .btn-secondary {
            background: #666;
            font-size: 14px;
        }
        
        .btn-success {
            background: #4CAF50;
        }
        
        .btn-success:hover {
            background: #388E3C;
        }
        
        .btn-demo {
            background: #2196F3;
            margin: 3px;
            padding: 10px;
            font-size: 13px;
        }
        
        .btn-demo:hover {
            background: #1976D2;
        }
        
        .quick-preset {
            display: flex;
            align-items: center;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            margin: 8px 0;
            cursor: pointer;
            transition: all 0.3s;
            background: white;
        }
        
        .quick-preset:hover {
            border-color: #B71C1C;
            background: #fff5f5;
        }
        
        .preset-icon {
            font-size: 24px;
            margin-right: 12px;
        }
        
        .preset-content {
            flex: 1;
        }
        
        .preset-title {
            font-weight: bold;
            color: #333;
            margin-bottom: 4px;
        }
        
        .preset-description {
            font-size: 12px;
            color: #666;
        }
        
        .help-text {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 4px;
        }
        
        .section-divider {
            height: 1px;
            background: #e0e0e0;
            margin: 25px 0;
        }
        
        .status-message {
            padding: 12px;
            border-radius: 8px;
            margin: 10px 0;
            display: none;
            animation: slideIn 0.3s;
        }
        
        .status-success {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }
        
        .status-error {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
        }
        
        .status-info {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            color: #0c5460;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255,255,255,0.95);
            padding: 30px;
            border-radius: 12px;
            text-align: center;
            display: none;
            z-index: 1000;
        }
        
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #B71C1C;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        @keyframes slideIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .legend-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 2px;
            width: 150px;
            height: 150px;
            margin: 20px auto;
            border: 2px solid #333;
            border-radius: 4px;
            overflow: hidden;
        }
        
        .legend-cell {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        
        .field-section {
            margin-top: 20px;
            padding: 15px;
            background: white;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
        }
        
        .demo-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        
        /* Responsive Design */
        @media (max-width: 1400px) {
            .main-grid {
                grid-template-columns: 280px 1fr 300px;
            }
        }
        
        @media (max-width: 1200px) {
            .main-grid {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto 1fr;
            }
            
            .right-sidebar {
                order: 1;
            }
            
            .left-sidebar {
                order: 2;
            }
            
            .map-container {
                order: 3;
                height: 600px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Bivariate Choropleth Mapper</h1>
        <p>Create professional maps by combining your data with geographic boundaries</p>
    </div>

    <div class="container">
        <div class="main-grid">
            <!-- LEFT SIDEBAR - Core User Workflows -->
            <div class="sidebar left-sidebar">
                <h2 style="color: #B71C1C; margin-bottom: 25px; text-align: center;">Start Here</h2>
                
                <!-- Workflow 1: CSV Upload -->
                <div class="workflow-section primary">
                    <h2><span class="step-number">1</span> Bring Your Own Data</h2>
                    <p style="color: #666; margin-bottom: 15px;">Upload a CSV file and match it to geographic boundaries</p>
                    
                    <h3>Upload Your CSV File</h3>
                    <input type="file" id="csvFile" accept=".csv">
                    <div class="help-text">Your CSV should have location names (like county names, state names) and data columns</div>
                    
                    <div id="csvPreview" style="display: none; margin-top: 15px;">
                        <h3>Select Geography to Match</h3>
                        <select id="geographyType" onchange="handleGeographyChange()">
                            <option value="">-- What type of locations are in your CSV? --</option>
                            <option value="arc_counties">US Counties</option>
                            <option value="states">US States</option>
                            <option value="divisions">Geographic Divisions</option>
                            <option value="regions">Geographic Regions</option>
                            <option value="chapters">ARC Chapters</option>
                            <optgroup label="ZIP Codes by Region">
                                <option value="zip_northeast">ZIP Codes - Northeast</option>
                                <option value="zip_southeast">ZIP Codes - Southeast</option>
                                <option value="zip_midwest">ZIP Codes - Midwest</option>
                                <option value="zip_south">ZIP Codes - South</option>
                                <option value="zip_west">ZIP Codes - West</option>
                            </optgroup>
                            <optgroup label="ZIP Codes by State">
                                <option value="zip_florida">ZIP Codes - Florida</option>
                                <option value="zip_texas">ZIP Codes - Texas</option>
                                <option value="zip_california">ZIP Codes - California</option>
                                <option value="zip_newyork">ZIP Codes - New York</option>
                            </optgroup>
                        </select>
                        
                        <div id="fieldMapping" style="display: none; margin-top: 15px;">
                            <h3>Match Your Data</h3>
                            <label>CSV column with location names:</label>
                            <select id="csvMatchField">
                                <option value="">-- Select column --</option>
                            </select>
                            
                            <button class="btn btn-success" onclick="matchAndMergeData()" style="margin-top: 15px;">
                                Match Data to Map
                            </button>
                        </div>
                    </div>
                </div>
                
                <div class="section-divider"></div>
                
                <!-- Workflow 2: ArcGIS Data -->
                <div class="workflow-section">
                    <h2><span class="step-number">2</span> Use Public ArcGIS Data</h2>
                    <p style="color: #666; margin-bottom: 15px;">Load data that already includes geographic boundaries</p>
                    
                    <h3>Quick Options</h3>
                    <div class="quick-preset" onclick="loadARCCounties()">
                        <span class="preset-icon">🏛️</span>
                        <div class="preset-content">
                            <div class="preset-title">US Counties with Demographics</div>
                            <div class="preset-description">3,142 counties with population data</div>
                        </div>
                    </div>
                    
                    <div class="quick-preset" onclick="loadRedCrossDivisions()">
                        <span class="preset-icon">🌎</span>
                        <div class="preset-content">
                            <div class="preset-title">Geographic Divisions</div>
                            <div class="preset-description">7 major US divisions</div>
                        </div>
                    </div>
                    
                    <div class="quick-preset" onclick="loadRedCrossRegions()">
                        <span class="preset-icon">🗺️</span>
                        <div class="preset-content">
                            <div class="preset-title">Geographic Regions</div>
                            <div class="preset-description">59 regional boundaries</div>
                        </div>
                    </div>
                    
                    <div class="quick-preset" onclick="loadARCStates()">
                        <span class="preset-icon">🇺🇸</span>
                        <div class="preset-content">
                            <div class="preset-title">US States</div>
                            <div class="preset-description">50 US states with data</div>
                        </div>
                    </div>
                    
                    <div class="quick-preset" onclick="loadARCChapters()">
                        <span class="preset-icon">🏢</span>
                        <div class="preset-content">
                            <div class="preset-title">ARC Chapters</div>
                            <div class="preset-description">250+ local chapters</div>
                        </div>
                    </div>
                    
                    <h3 style="margin-top: 20px;">ZIP Code Regions</h3>
                    <div style="font-size: 12px; color: #666; margin-bottom: 10px;">
                        Note: ZIP codes work best with CSV data upload (Step 1 on left)
                    </div>
                    
                    <div class="quick-preset" onclick="showZIPMessage('Florida')">
                        <span class="preset-icon">📍</span>
                        <div class="preset-content">
                            <div class="preset-title">Florida ZIP Codes</div>
                            <div class="preset-description">All FL ZIP codes</div>
                        </div>
                    </div>
                    
                    <div class="quick-preset" onclick="showZIPMessage('Texas')">
                        <span class="preset-icon">📍</span>
                        <div class="preset-content">
                            <div class="preset-title">Texas ZIP Codes</div>
                            <div class="preset-description">All TX ZIP codes</div>
                        </div>
                    </div>
                    
                    <div class="quick-preset" onclick="showZIPMessage('Northeast')">
                        <span class="preset-icon">📍</span>
                        <div class="preset-content">
                            <div class="preset-title">Northeast ZIP Codes</div>
                            <div class="preset-description">CT, ME, MA, NH, NJ, NY, PA, RI, VT</div>
                        </div>
                    </div>
                    
                    <h3 style="margin-top: 20px;">Custom ArcGIS URL</h3>
                    <input type="url" id="customServiceUrl" placeholder="https://services.arcgis.com/.../FeatureServer/0">
                    <div class="help-text">Paste a public ArcGIS Feature Service URL</div>
                    <button class="btn btn-secondary" onclick="loadCustomService()">
                        Load Custom Service
                    </button>
                </div>
                
                <!-- Field Selection (appears after data is loaded) -->
                <div id="fieldSelection" style="display: none; margin-top: 30px;">
                    <div class="field-section">
                        <h3>Create Your Map</h3>
                        <div id="fieldCount" class="help-text"></div>
                        
                        <label>First Variable (X-axis):</label>
                        <select id="xVariable">
                            <option value="">-- Select first variable --</option>
                        </select>
                        
                        <label style="margin-top: 15px;">Second Variable (Y-axis):</label>
                        <select id="yVariable">
                            <option value="">-- Select second variable --</option>
                        </select>
                        
                        <button class="btn btn-primary" onclick="generateBivariateMap()" style="margin-top: 20px;">
                            Create Bivariate Map
                        </button>
                    </div>
                </div>
            </div>

            <!-- CENTER - Map -->
            <div class="map-container">
                <div id="status" class="status-message"></div>
                <button onclick="resetAll()" style="position: absolute; top: 20px; right: 20px; z-index: 1000; background: #ff5722; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer;">
                    Reset All
                </button>
                <div id="map"></div>
                <div class="loading" id="loading">
                    <div class="spinner"></div>
                    <p>Loading data...</p>
                </div>
                
                <!-- Legend (appears after map is generated) -->
                <div id="legendSection" style="display: none; position: absolute; bottom: 20px; left: 20px; background: white; padding: 15px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.3);">
                    <h4 style="margin-bottom: 10px; text-align: center;">Map Legend</h4>
                    <div class="legend-grid" id="legendGrid"></div>
                    <div style="display: flex; justify-content: space-between; margin-top: 10px; font-size: 12px;">
                        <span id="xLabel">→ Variable 1</span>
                        <span id="yLabel">↑ Variable 2</span>
                    </div>
                </div>
            </div>

            <!-- RIGHT SIDEBAR - Demos & Examples -->
            <div class="sidebar right-sidebar">
                <h2 style="color: #2196F3; margin-bottom: 25px; text-align: center;">Examples & Demos</h2>
                
                <div class="demo-section">
                    <h3>🚀 Quick Demos</h3>
                    <p style="font-size: 12px; color: #666; margin-bottom: 15px;">See the tool in action with sample data</p>
                    
                    <div class="demo-grid">
                        <button class="btn btn-demo" onclick="quickDemo('divisions')">
                            🌎 Divisions Demo
                        </button>
                        <button class="btn btn-demo" onclick="quickDemo('regions')">
                            🗺️ Regions Demo
                        </button>
                        <button class="btn btn-demo" onclick="quickDemo('counties')">
                            🏛️ Counties Demo
                        </button>
                        <button class="btn btn-demo" onclick="quickDemo('chapters')">
                            🏢 Chapters Demo
                        </button>
                    </div>
                </div>
                
                <div class="demo-section">
                    <h3>📊 CSV Examples</h3>
                    <p style="font-size: 12px; color: #666; margin-bottom: 15px;">Try these sample CSV files to understand the workflow</p>
                    
                    <button class="btn btn-demo" onclick="loadSampleCSV('divisions')" style="width: 100%; margin: 4px 0;">
                        Sample Division Data
                    </button>
                    <button class="btn btn-demo" onclick="loadSampleCSV('counties')" style="width: 100%; margin: 4px 0;">
                        Sample County Data
                    </button>
                    <button class="btn btn-demo" onclick="loadSampleCSV('regions')" style="width: 100%; margin: 4px 0;">
                        Sample Region Data
                    </button>
                </div>
                
                <div class="demo-section">
                    <h3>🌟 Featured Demo</h3>
                    <p style="font-size: 12px; color: #666; margin-bottom: 15px;">Real data example: ALICE (Asset Limited, Income Constrained, Employed) households in Florida</p>
                    
                    <button class="btn" onclick="runFloridaALICEOneClick()" style="background: linear-gradient(135deg, #4CAF50, #8BC34A); width: 100%; padding: 15px; font-weight: bold;">
                        🎯 Florida ALICE Demo
                    </button>
                    <div class="help-text">This loads real economic data for Florida counties</div>
                </div>
                
                <div class="demo-section">
                    <h3>💡 How It Works</h3>
                    <div style="font-size: 12px; color: #666; line-height: 1.5;">
                        <p><strong>Bivariate maps</strong> show the relationship between two variables using a color grid.</p>
                        <br>
                        <p><strong>For your own data:</strong></p>
                        <ol style="margin-left: 15px;">
                            <li>Upload CSV with location names</li>
                            <li>Match to geographic boundaries</li>
                            <li>Select two data columns to compare</li>
                            <li>Generate the map</li>
                        </ol>
                        <br>
                        <p><strong>For public data:</strong> Choose a preset geographic dataset and pick two variables to visualize.</p>
                    </div>
                </div>
                
                <!-- Statistics (appears after map is generated) -->
                <div id="statsSection" style="display: none;">
                    <div class="demo-section">
                        <h3>📈 Analysis Results</h3>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px;">
                            <div style="text-align: center; padding: 10px; background: white; border-radius: 4px;">
                                <div style="font-size: 18px; font-weight: bold; color: #B71C1C;" id="correlationValue">--</div>
                                <div style="font-size: 12px; color: #666;">Correlation</div>
                            </div>
                            <div style="text-align: center; padding: 10px; background: white; border-radius: 4px;">
                                <div style="font-size: 18px; font-weight: bold; color: #B71C1C;" id="featureCount">--</div>
                                <div style="font-size: 12px; color: #666;">Features</div>
                            </div>
                        </div>
                        
                        <h4 style="margin-bottom: 10px;">Distribution</h4>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px; font-size: 11px;">
                            <div style="background: #ff6b6b; color: white; padding: 8px; text-align: center; border-radius: 3px;">
                                <div>High-High</div>
                                <div id="highHighCount">0</div>
                            </div>
                            <div style="background: #ff9f43; color: white; padding: 8px; text-align: center; border-radius: 3px;">
                                <div>High-Low</div>
                                <div id="highLowCount">0</div>
                            </div>
                            <div style="background: #54a0ff; color: white; padding: 8px; text-align: center; border-radius: 3px;">
                                <div>Low-High</div>
                                <div id="lowHighCount">0</div>
                            </div>
                            <div style="background: #5f27cd; color: white; padding: 8px; text-align: center; border-radius: 3px;">
                                <div>Low-Low</div>
                                <div id="lowLowCount">0</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Export Options (appears after map is generated) -->
                <div id="exportSection" style="display: none;">
                    <div class="demo-section">
                        <h3>💾 Export Options</h3>
                        <button class="btn btn-demo" onclick="exportData('csv')" style="width: 100%; margin: 4px 0;">
                            Export CSV Data
                        </button>
                        <button class="btn btn-demo" onclick="exportData('geojson')" style="width: 100%; margin: 4px 0;">
                            Export GeoJSON
                        </button>
                        <button class="btn btn-demo" onclick="exportData('image')" style="width: 100%; margin: 4px 0;">
                            Save Map Image
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let map;
        let currentLayer;
        let currentData = [];
        let currentFields = [];
        let currentGeometry = null;
        let csvData = null;
        let csvFields = [];
        let matchedGeography = null;

        // Initialize map
        function initMap() {
            map = L.map('map').setView([39.8283, -98.5795], 4);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© OpenStreetMap contributors'
            }).addTo(map);
        }

        // Status message functions
        function showStatus(message, type = 'info') {
            const statusDiv = document.getElementById('status');
            statusDiv.className = `status-message status-${type}`;
            statusDiv.textContent = message;
            statusDiv.style.display = 'block';
            
            if (type === 'success' || type === 'info') {
                setTimeout(() => {
                    statusDiv.style.display = 'none';
                }, 5000);
            }
        }

        function showLoading(show = true) {
            document.getElementById('loading').style.display = show ? 'block' : 'none';
        }

        // CSV file handling
        document.getElementById('csvFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                showLoading(true);
                showStatus('Reading CSV file...', 'info');
                
                Papa.parse(file, {
                    header: true,
                    complete: function(results) {
                        showLoading(false);
                        if (results.errors.length > 0) {
                            showStatus('Error reading CSV: ' + results.errors[0].message, 'error');
                            return;
                        }
                        
                        csvData = results.data.filter(row => Object.values(row).some(val => val && val.trim()));
                        csvFields = Object.keys(csvData[0] || {});
                        
                        showStatus(`CSV loaded: ${csvData.length} rows, ${csvFields.length} columns`, 'success');
                        
                        // Show the CSV preview section
                        document.getElementById('csvPreview').style.display = 'block';
                        
                        // Populate the CSV match field dropdown
                        const csvMatchField = document.getElementById('csvMatchField');
                        csvMatchField.innerHTML = '<option value="">-- Select column --</option>';
                        csvFields.forEach(field => {
                            csvMatchField.innerHTML += `<option value="${field}">${field}</option>`;
                        });
                    },
                    error: function(error) {
                        showLoading(false);
                        showStatus('Error reading CSV file: ' + error.message, 'error');
                    }
                });
            }
        });

        // Geography type change handler
        function handleGeographyChange() {
            const geoType = document.getElementById('geographyType').value;
            if (geoType && csvData) {
                document.getElementById('fieldMapping').style.display = 'block';
                showStatus(`Ready to match CSV data to ${geoType}`, 'info');
            }
        }

        // Reset all functionality
        function resetAll() {
            // Clear map
            if (currentLayer) {
                map.removeLayer(currentLayer);
                currentLayer = null;
            }
            
            // Reset variables
            currentData = [];
            currentFields = [];
            csvData = null;
            csvFields = [];
            matchedGeography = null;
            
            // Hide sections
            document.getElementById('csvPreview').style.display = 'none';
            document.getElementById('fieldMapping').style.display = 'none';
            document.getElementById('fieldSelection').style.display = 'none';
            document.getElementById('legendSection').style.display = 'none';
            document.getElementById('statsSection').style.display = 'none';
            document.getElementById('exportSection').style.display = 'none';
            
            // Clear inputs
            document.getElementById('csvFile').value = '';
            document.getElementById('customServiceUrl').value = '';
            document.getElementById('geographyType').value = '';
            document.getElementById('csvMatchField').value = '';
            document.getElementById('xVariable').value = '';
            document.getElementById('yVariable').value = '';
            
            // Clear status
            document.getElementById('status').style.display = 'none';
            
            showStatus('All data cleared', 'info');
        }

        // Load ARC Counties (Using Jeff's custom layer with enhanced pop-ups)
        function loadARCCounties() {
            showLoading(true);
            showStatus('Loading US Counties data...', 'info');
            
            // Using Master ARC Geography 2022 - County layer
            const url = 'https://services.arcgis.com/pGfbNJoYypmNq86F/arcgis/rest/services/Master_ARC_Geography_2022/FeatureServer/5';
            loadArcGISService(url, 'ALL');
        }

        // Load Red Cross Divisions (Jeff's hosted layer with custom pop-ups)
        function loadRedCrossDivisions() {
            showLoading(true);
            showStatus('Loading Geographic Divisions...', 'info');
            
            const url = 'https://services.arcgis.com/pGfbNJoYypmNq86F/arcgis/rest/services/Master_ARC_Geography_2022/FeatureServer/1';
            loadArcGISService(url, 'CONUS');
        }

        // Load Red Cross Regions (Jeff's hosted layer with custom pop-ups)
        function loadRedCrossRegions() {
            showLoading(true);
            showStatus('Loading Geographic Regions...', 'info');
            
            const url = 'https://services.arcgis.com/pGfbNJoYypmNq86F/arcgis/rest/services/Master_ARC_Geography_2022/FeatureServer/2';
            loadArcGISService(url, 'CONUS');
        }
        
        // Load US States
        function loadARCStates() {
            showLoading(true);
            showStatus('Loading US States data...', 'info');
            
            const url = 'https://services.arcgis.com/pGfbNJoYypmNq86F/arcgis/rest/services/Master_ARC_Geography_2022/FeatureServer/3';
            loadArcGISService(url, 'CONUS');
        }
        
        // Load ARC Chapters (Jeff's hosted layer with custom pop-ups)
        function loadARCChapters() {
            showLoading(true);
            showStatus('Loading ARC Chapters data...', 'info');
            
            const url = 'https://services.arcgis.com/pGfbNJoYypmNq86F/arcgis/rest/services/Master_ARC_Geography_2022/FeatureServer/4';
            loadArcGISService(url, 'CONUS');
        }
        
        // Show ZIP code message
        function showZIPMessage(region) {
            showStatus(`ZIP codes require CSV upload. Please use Step 1 (Bring Your Own Data) and select "ZIP Codes - ${region}" after uploading your CSV file.`, 'info');
            
            // Highlight the CSV upload section
            const csvSection = document.querySelector('.workflow-section');
            if (csvSection) {
                csvSection.style.border = '2px solid #ff5722';
                setTimeout(() => {
                    csvSection.style.border = '';
                }, 3000);
            }
        }

        // Load custom service
        function loadCustomService() {
            const url = document.getElementById('customServiceUrl').value.trim();
            if (!url) {
                showStatus('Please enter a valid ArcGIS service URL', 'error');
                return;
            }
            
            showLoading(true);
            showStatus('Loading custom ArcGIS service...', 'info');
            loadArcGISService(url);
        }

        // Generic ArcGIS service loader
        function loadArcGISService(baseUrl, zoomType = 'FIT') {
            const queryUrl = `${baseUrl}/query?where=1%3D1&outFields=*&outSR=4326&f=geojson&resultRecordCount=5000`;
            
            fetch(queryUrl)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    showLoading(false);
                    
                    if (!data.features || data.features.length === 0) {
                        showStatus('No features found in the service', 'error');
                        return;
                    }
                    
                    currentData = data.features;
                    
                    // Extract field names from the first feature
                    if (currentData[0] && currentData[0].properties) {
                        currentFields = Object.keys(currentData[0].properties).filter(field => {
                            const value = currentData[0].properties[field];
                            return typeof value === 'number' && !isNaN(value);
                        });
                    }
                    
                    showStatus(`Loaded ${currentData.length} features with ${currentFields.length} numeric fields`, 'success');
                    
                    // Add to map
                    if (currentLayer) {
                        map.removeLayer(currentLayer);
                    }
                    
                    currentLayer = L.geoJSON(data, {
                        style: {
                            fillColor: '#3388ff',
                            fillOpacity: 0.6,
                            color: '#fff',
                            weight: 1
                        },
                        onEachFeature: function(feature, layer) {
                            let popupContent = '<h4>Feature Properties</h4>';
                            for (const [key, value] of Object.entries(feature.properties)) {
                                if (value !== null && value !== undefined && value !== '') {
                                    popupContent += `<strong>${key}:</strong> ${value}<br>`;
                                }
                            }
                            layer.bindPopup(popupContent);
                        }
                    }).addTo(map);
                    
                    // Smart zoom based on data type
                    if (zoomType === 'CONUS') {
                        // Continental US bounds
                        map.fitBounds([
                            [24.396308, -125.0],  // Southwest
                            [49.384358, -66.93457] // Northeast
                        ]);
                    } else if (zoomType === 'ALL') {
                        // Show all features but limit zoom
                        const bounds = currentLayer.getBounds();
                        map.fitBounds(bounds, { maxZoom: 5 });
                    } else {
                        // Default: fit to data
                        map.fitBounds(currentLayer.getBounds());
                    }
                    
                    // Show field selection
                    showFieldSelection();
                })
                .catch(error => {
                    showLoading(false);
                    console.error('Error loading ArcGIS service:', error);
                    showStatus('Error loading service: ' + error.message, 'error');
                });
        }

        // Handle ZIP Code region loading
        function handleZIPCodeRegion(geoType, csvMatchField) {
            showLoading(true);
            
            // Define state codes for each region
            const regionStates = {
                'zip_northeast': ['CT', 'ME', 'MA', 'NH', 'NJ', 'NY', 'PA', 'RI', 'VT'],
                'zip_southeast': ['AL', 'AR', 'FL', 'GA', 'KY', 'LA', 'MS', 'NC', 'SC', 'TN', 'VA', 'WV'],
                'zip_midwest': ['IL', 'IN', 'IA', 'KS', 'MI', 'MN', 'MO', 'NE', 'ND', 'OH', 'SD', 'WI'],
                'zip_south': ['TX', 'OK', 'NM'],
                'zip_west': ['AZ', 'CA', 'CO', 'ID', 'MT', 'NV', 'OR', 'UT', 'WA', 'WY', 'AK', 'HI'],
                'zip_florida': ['FL'],
                'zip_texas': ['TX'],
                'zip_california': ['CA'],
                'zip_newyork': ['NY']
            };
            
            const states = regionStates[geoType];
            if (!states) {
                showStatus('Invalid ZIP region selected', 'error');
                showLoading(false);
                return;
            }
            
            // Build WHERE clause for states
            const stateConditions = states.map(state => `STATE='${state}'`).join(' OR ');
            const whereClause = `(${stateConditions})`;
            
            // ESRI's public ZIP code service
            const baseUrl = 'https://services.arcgis.com/P3ePLMYs2RVChkJx/arcgis/rest/services/USA_ZIP_Codes/FeatureServer/0';
            const queryUrl = `${baseUrl}/query?where=${encodeURIComponent(whereClause)}&outFields=*&outSR=4326&f=geojson&resultRecordCount=10000`;
            
            showStatus(`Loading ${states.join(', ')} ZIP codes...`, 'info');
            
            fetch(queryUrl)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(geoData => {
                    if (!geoData.features || geoData.features.length === 0) {
                        throw new Error('No ZIP codes found for selected region');
                    }
                    
                    // Match CSV data to ZIP codes
                    const mergedFeatures = [];
                    let matchCount = 0;
                    
                    geoData.features.forEach(geoFeature => {
                        const zipCode = geoFeature.properties.ZIP || geoFeature.properties.ZCTA5 || geoFeature.properties.ZIP_CODE;
                        
                        if (!zipCode) return;
                        
                        // Find matching CSV row
                        const csvRow = csvData.find(row => {
                            const csvValue = row[csvMatchField];
                            if (!csvValue) return false;
                            
                            // Normalize ZIP codes (remove leading zeros issues)
                            const csvZip = csvValue.toString().padStart(5, '0');
                            const geoZip = zipCode.toString().padStart(5, '0');
                            
                            return csvZip === geoZip;
                        });
                        
                        if (csvRow) {
                            matchCount++;
                            const mergedProperties = {
                                ...geoFeature.properties,
                                ...csvRow
                            };
                            
                            mergedFeatures.push({
                                ...geoFeature,
                                properties: mergedProperties
                            });
                        }
                    });
                    
                    showLoading(false);
                    
                    if (matchCount === 0) {
                        showStatus(`No matches found. Loaded ${geoData.features.length} ZIP codes for region but no CSV matches.`, 'error');
                        return;
                    }
                    
                    currentData = mergedFeatures;
                    
                    // Extract numeric fields
                    if (currentData[0] && currentData[0].properties) {
                        currentFields = Object.keys(currentData[0].properties).filter(field => {
                            const value = currentData[0].properties[field];
                            return typeof value === 'number' || 
                                   (!isNaN(parseFloat(value)) && isFinite(value));
                        });
                    }
                    
                    showStatus(`Successfully matched ${matchCount} ZIP codes with ${currentFields.length} data fields`, 'success');
                    
                    // Add to map
                    if (currentLayer) {
                        map.removeLayer(currentLayer);
                    }
                    
                    currentLayer = L.geoJSON({
                        type: 'FeatureCollection',
                        features: currentData
                    }, {
                        style: {
                            fillColor: '#3388ff',
                            fillOpacity: 0.6,
                            color: '#fff',
                            weight: 0.5  // Thinner borders for ZIP codes
                        },
                        onEachFeature: function(feature, layer) {
                            const zip = feature.properties.ZIP || feature.properties.ZCTA5 || feature.properties.ZIP_CODE;
                            let popupContent = `<h4>ZIP: ${zip}</h4>`;
                            for (const [key, value] of Object.entries(feature.properties)) {
                                if (value !== null && value !== undefined && value !== '') {
                                    popupContent += `<strong>${key}:</strong> ${value}<br>`;
                                }
                            }
                            layer.bindPopup(popupContent);
                        }
                    }).addTo(map);
                    
                    // Smart zoom based on data type
                    if (zoomType === 'CONUS') {
                        // Continental US bounds
                        map.fitBounds([
                            [24.396308, -125.0],  // Southwest
                            [49.384358, -66.93457] // Northeast
                        ]);
                    } else if (zoomType === 'ALL') {
                        // Show all features but limit zoom
                        const bounds = currentLayer.getBounds();
                        map.fitBounds(bounds, { maxZoom: 5 });
                    } else {
                        // Default: fit to data
                        map.fitBounds(currentLayer.getBounds());
                    }
                    
                    // Show field selection
                    showFieldSelection();
                })
                .catch(error => {
                    showLoading(false);
                    console.error('Error loading ZIP codes:', error);
                    showStatus('Error loading ZIP codes: ' + error.message, 'error');
                });
        }
        
        // Show field selection interface
        function showFieldSelection() {
            const fieldSelection = document.getElementById('fieldSelection');
            const fieldCount = document.getElementById('fieldCount');
            const xVariable = document.getElementById('xVariable');
            const yVariable = document.getElementById('yVariable');
            
            fieldCount.textContent = `Found ${currentFields.length} numeric fields available for mapping`;
            
            // Populate dropdowns
            xVariable.innerHTML = '<option value="">-- Select first variable --</option>';
            yVariable.innerHTML = '<option value="">-- Select second variable --</option>';
            
            currentFields.forEach(field => {
                xVariable.innerHTML += `<option value="${field}">${field}</option>`;
                yVariable.innerHTML += `<option value="${field}">${field}</option>`;
            });
            
            fieldSelection.style.display = 'block';
        }

        // Match and merge CSV data
        function matchAndMergeData() {
            const geoType = document.getElementById('geographyType').value;
            const csvMatchField = document.getElementById('csvMatchField').value;
            
            if (!geoType || !csvMatchField) {
                showStatus('Please select both geography type and CSV field to match', 'error');
                return;
            }
            
            showLoading(true);
            showStatus('Matching CSV data to geography...', 'info');
            
            // Load the appropriate geography
            let geoUrl;
            switch (geoType) {
                case 'arc_counties':
                    geoUrl = 'https://services.arcgis.com/pGfbNJoYypmNq86F/arcgis/rest/services/Master_ARC_Geography_2022/FeatureServer/5';
                    break;
                case 'states':
                    geoUrl = 'https://services.arcgis.com/pGfbNJoYypmNq86F/arcgis/rest/services/Master_ARC_Geography_2022/FeatureServer/3';
                    break;
                case 'divisions':
                    geoUrl = 'https://services.arcgis.com/pGfbNJoYypmNq86F/arcgis/rest/services/ARC%20Division%20with%20Demographics/FeatureServer/0';
                    break;
                case 'regions':
                    geoUrl = 'https://services.arcgis.com/pGfbNJoYypmNq86F/arcgis/rest/services/ARC%20Region%20with%20Demographics/FeatureServer/0';
                    break;
                case 'chapters':
                    geoUrl = 'https://services.arcgis.com/pGfbNJoYypmNq86F/arcgis/rest/services/ARC_Chapter_with_Demographics/FeatureServer/0';
                    break;
                // ZIP Code regions using ESRI's public ZIP service
                case 'zip_northeast':
                case 'zip_southeast':
                case 'zip_midwest':
                case 'zip_south':
                case 'zip_west':
                case 'zip_florida':
                case 'zip_texas':
                case 'zip_california':
                case 'zip_newyork':
                    handleZIPCodeRegion(geoType, csvMatchField);
                    return;
                default:
                    showLoading(false);
                    showStatus('Invalid geography type selected', 'error');
                    return;
            }
            
            const queryUrl = `${geoUrl}/query?where=1%3D1&outFields=*&outSR=4326&f=geojson&resultRecordCount=2000`;
            
            fetch(queryUrl)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(geoData => {
                    // Merge CSV data with geography
                    const mergedFeatures = [];
                    let matchCount = 0;
                    
                    geoData.features.forEach(geoFeature => {
                        // Try to find matching CSV row
                        const csvRow = csvData.find(row => {
                            const csvValue = row[csvMatchField];
                            const geoValue = geoFeature.properties.NAME || 
                                           geoFeature.properties.State || 
                                           geoFeature.properties.COUNTY || 
                                           geoFeature.properties.Division ||
                                           geoFeature.properties.Region;
                            
                            if (!csvValue || !geoValue) return false;
                            
                            return csvValue.toString().toLowerCase().trim() === 
                                   geoValue.toString().toLowerCase().trim();
                        });
                        
                        if (csvRow) {
                            matchCount++;
                            // Merge properties
                            const mergedProperties = {
                                ...geoFeature.properties,
                                ...csvRow
                            };
                            
                            mergedFeatures.push({
                                ...geoFeature,
                                properties: mergedProperties
                            });
                        }
                    });
                    
                    showLoading(false);
                    
                    if (matchCount === 0) {
                        showStatus('No matches found between CSV and geography data', 'error');
                        return;
                    }
                    
                    currentData = mergedFeatures;
                    
                    // Extract numeric fields from merged data
                    if (currentData[0] && currentData[0].properties) {
                        currentFields = Object.keys(currentData[0].properties).filter(field => {
                            const value = currentData[0].properties[field];
                            return typeof value === 'number' || 
                                   (!isNaN(parseFloat(value)) && isFinite(value));
                        });
                    }
                    
                    showStatus(`Successfully matched ${matchCount} features with ${currentFields.length} data fields`, 'success');
                    
                    // Add to map
                    if (currentLayer) {
                        map.removeLayer(currentLayer);
                    }
                    
                    currentLayer = L.geoJSON({
                        type: 'FeatureCollection',
                        features: currentData
                    }, {
                        style: {
                            fillColor: '#3388ff',
                            fillOpacity: 0.6,
                            color: '#fff',
                            weight: 1
                        },
                        onEachFeature: function(feature, layer) {
                            let popupContent = '<h4>Merged Data</h4>';
                            for (const [key, value] of Object.entries(feature.properties)) {
                                if (value !== null && value !== undefined && value !== '') {
                                    popupContent += `<strong>${key}:</strong> ${value}<br>`;
                                }
                            }
                            layer.bindPopup(popupContent);
                        }
                    }).addTo(map);
                    
                    // Smart zoom based on data type
                    if (zoomType === 'CONUS') {
                        // Continental US bounds
                        map.fitBounds([
                            [24.396308, -125.0],  // Southwest
                            [49.384358, -66.93457] // Northeast
                        ]);
                    } else if (zoomType === 'ALL') {
                        // Show all features but limit zoom
                        const bounds = currentLayer.getBounds();
                        map.fitBounds(bounds, { maxZoom: 5 });
                    } else {
                        // Default: fit to data
                        map.fitBounds(currentLayer.getBounds());
                    }
                    
                    // Show field selection
                    showFieldSelection();
                })
                .catch(error => {
                    showLoading(false);
                    console.error('Error loading geography:', error);
                    showStatus('Error loading geography: ' + error.message, 'error');
                });
        }

        // Generate bivariate map
        function generateBivariateMap() {
            const xVar = document.getElementById('xVariable').value;
            const yVar = document.getElementById('yVariable').value;
            
            if (!xVar || !yVar) {
                showStatus('Please select both X and Y variables', 'error');
                return;
            }
            
            if (xVar === yVar) {
                showStatus('Please select different variables for X and Y axes', 'error');
                return;
            }
            
            showLoading(true);
            showStatus('Generating bivariate map...', 'info');
            
            // Extract values for classification
            const xValues = [];
            const yValues = [];
            
            currentData.forEach(feature => {
                const xVal = parseFloat(feature.properties[xVar]);
                const yVal = parseFloat(feature.properties[yVar]);
                
                if (!isNaN(xVal) && !isNaN(yVal)) {
                    xValues.push(xVal);
                    yValues.push(yVal);
                }
            });
            
            if (xValues.length === 0 || yValues.length === 0) {
                showLoading(false);
                showStatus('No valid numeric data found for selected variables', 'error');
                return;
            }
            
            // Calculate quantile breaks (3x3 grid)
            const xBreaks = calculateQuantileBreaks(xValues, 3);
            const yBreaks = calculateQuantileBreaks(yValues, 3);
            
            // Bivariate color scheme (3x3 grid)
            const colorMatrix = [
                ['#e8e8e8', '#dfb0d6', '#be64ac'],
                ['#ace4e4', '#a5add3', '#8c62aa'],
                ['#5ac8c8', '#5698b9', '#3b4994']
            ];
            
            // Update layer styling
            if (currentLayer) {
                map.removeLayer(currentLayer);
            }
            
            currentLayer = L.geoJSON({
                type: 'FeatureCollection',
                features: currentData
            }, {
                style: function(feature) {
                    const xVal = parseFloat(feature.properties[xVar]);
                    const yVal = parseFloat(feature.properties[yVar]);
                    
                    if (isNaN(xVal) || isNaN(yVal)) {
                        return {
                            fillColor: '#cccccc',
                            fillOpacity: 0.7,
                            color: '#fff',
                            weight: 1
                        };
                    }
                    
                    const xClass = classifyValue(xVal, xBreaks);
                    const yClass = classifyValue(yVal, yBreaks);
                    
                    return {
                        fillColor: colorMatrix[yClass][xClass],
                        fillOpacity: 0.8,
                        color: '#fff',
                        weight: 1
                    };
                },
                onEachFeature: function(feature, layer) {
                    const xVal = feature.properties[xVar];
                    const yVal = feature.properties[yVar];
                    
                    let popupContent = `<h4>Bivariate Analysis</h4>`;
                    popupContent += `<strong>${xVar}:</strong> ${xVal}<br>`;
                    popupContent += `<strong>${yVar}:</strong> ${yVal}<br><hr>`;
                    
                    for (const [key, value] of Object.entries(feature.properties)) {
                        if (key !== xVar && key !== yVar && value !== null && value !== undefined && value !== '') {
                            popupContent += `<strong>${key}:</strong> ${value}<br>`;
                        }
                    }
                    
                    layer.bindPopup(popupContent);
                }
            }).addTo(map);
            
            // Generate legend
            generateLegend(colorMatrix, xVar, yVar);
            
            // Calculate statistics
            calculateStatistics(xValues, yValues, xBreaks, yBreaks);
            
            showLoading(false);
            showStatus('Bivariate map generated successfully!', 'success');
            
            // Show export options
            document.getElementById('exportSection').style.display = 'block';
        }

        // Helper function to calculate quantile breaks
        function calculateQuantileBreaks(values, numClasses) {
            const sorted = values.sort((a, b) => a - b);
            const breaks = [];
            
            for (let i = 1; i < numClasses; i++) {
                const index = Math.floor((i / numClasses) * sorted.length);
                breaks.push(sorted[index]);
            }
            
            return breaks;
        }

        // Helper function to classify a value into a class
        function classifyValue(value, breaks) {
            for (let i = 0; i < breaks.length; i++) {
                if (value <= breaks[i]) {
                    return i;
                }
            }
            return breaks.length;
        }

        // Generate legend
        function generateLegend(colorMatrix, xVar, yVar) {
            const legendGrid = document.getElementById('legendGrid');
            const xLabel = document.getElementById('xLabel');
            const yLabel = document.getElementById('yLabel');
            
            legendGrid.innerHTML = '';
            
            for (let y = 2; y >= 0; y--) {
                for (let x = 0; x < 3; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'legend-cell';
                    cell.style.backgroundColor = colorMatrix[y][x];
                    legendGrid.appendChild(cell);
                }
            }
            
            xLabel.textContent = `→ ${xVar}`;
            yLabel.textContent = `↑ ${yVar}`;
            
            document.getElementById('legendSection').style.display = 'block';
        }

        // Calculate statistics
        function calculateStatistics(xValues, yValues, xBreaks, yBreaks) {
            // Calculate correlation
            const correlation = calculateCorrelation(xValues, yValues);
            
            // Count features in each quadrant
            let highHigh = 0, highLow = 0, lowHigh = 0, lowLow = 0;
            
            for (let i = 0; i < xValues.length; i++) {
                const xClass = classifyValue(xValues[i], xBreaks);
                const yClass = classifyValue(yValues[i], yBreaks);
                
                if (xClass >= 2 && yClass >= 2) highHigh++;
                else if (xClass >= 2 && yClass < 2) highLow++;
                else if (xClass < 2 && yClass >= 2) lowHigh++;
                else lowLow++;
            }
            
            // Update UI
            document.getElementById('correlationValue').textContent = correlation.toFixed(3);
            document.getElementById('featureCount').textContent = xValues.length;
            document.getElementById('highHighCount').textContent = highHigh;
            document.getElementById('highLowCount').textContent = highLow;
            document.getElementById('lowHighCount').textContent = lowHigh;
            document.getElementById('lowLowCount').textContent = lowLow;
            
            document.getElementById('statsSection').style.display = 'block';
        }

        // Calculate correlation coefficient
        function calculateCorrelation(x, y) {
            const n = x.length;
            const sumX = x.reduce((a, b) => a + b, 0);
            const sumY = y.reduce((a, b) => a + b, 0);
            const sumXY = x.reduce((sum, xi, i) => sum + xi * y[i], 0);
            const sumXX = x.reduce((sum, xi) => sum + xi * xi, 0);
            const sumYY = y.reduce((sum, yi) => sum + yi * yi, 0);
            
            const numerator = n * sumXY - sumX * sumY;
            const denominator = Math.sqrt((n * sumXX - sumX * sumX) * (n * sumYY - sumY * sumY));
            
            return denominator === 0 ? 0 : numerator / denominator;
        }

        // Demo functions (simplified versions)
        function quickDemo(type) {
            showStatus(`Loading ${type} demo...`, 'info');
            
            switch (type) {
                case 'divisions':
                    loadRedCrossDivisions();
                    break;
                case 'regions':
                    loadRedCrossRegions();
                    break;
                case 'counties':
                    loadARCCounties();
                    break;
                case 'chapters':
                    // Load chapters demo
                    showStatus('Chapters demo would load here', 'info');
                    break;
            }
        }

        function loadSampleCSV(type) {
            showStatus(`Loading sample ${type} CSV...`, 'info');
            // This would load sample CSV data
            // Implementation depends on having sample files available
        }

        function runFloridaALICEOneClick() {
            showStatus('Loading Florida ALICE demo...', 'info');
            // This would load the full Florida ALICE demonstration
            // Implementation depends on having the ALICE data available
        }

        // Export functions
        function exportData(format) {
            showStatus(`Exporting data as ${format}...`, 'info');
            
            switch (format) {
                case 'csv':
                    exportCSV();
                    break;
                case 'geojson':
                    exportGeoJSON();
                    break;
                case 'image':
                    exportMapImage();
                    break;
            }
        }

        function exportCSV() {
            if (!currentData || currentData.length === 0) {
                showStatus('No data to export', 'error');
                return;
            }
            
            const csvContent = convertToCSV(currentData);
            downloadFile(csvContent, 'bivariate_map_data.csv', 'text/csv');
        }

        function exportGeoJSON() {
            if (!currentData || currentData.length === 0) {
                showStatus('No data to export', 'error');
                return;
            }
            
            const geojson = {
                type: 'FeatureCollection',
                features: currentData
            };
            
            downloadFile(JSON.stringify(geojson, null, 2), 'bivariate_map.geojson', 'application/json');
        }

        function exportMapImage() {
            showStatus('Map image export would be implemented here', 'info');
        }

        function convertToCSV(features) {
            if (!features || features.length === 0) return '';
            
            const headers = Object.keys(features[0].properties);
            const rows = features.map(feature => 
                headers.map(header => feature.properties[header] || '').join(',')
            );
            
            return [headers.join(','), ...rows].join('\n');
        }

        function downloadFile(content, filename, contentType) {
            const blob = new Blob([content], { type: contentType });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);
            
            showStatus(`${filename} downloaded successfully`, 'success');
        }

        // Initialize map when page loads
        document.addEventListener('DOMContentLoaded', function() {
            initMap();
            showStatus('Map initialized. Choose a workflow from the left panel to get started.', 'info');
        });
    </script>
</body>
</html>